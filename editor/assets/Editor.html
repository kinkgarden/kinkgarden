<div class="link-box-wrapper">
    <input type="text" disabled value={listUrl}>
</div>
<article>
    <aside>
        <div class="category-menu">
            <h2>Categories</h2>
            {#await categories}
            <p class="loading">loading...</p>
            {:then categories}
            <ul>
                <li class:selected="is_selected(null)" on:click="select_category(null)">all kinks</li>
                <li class:selected="is_selected('custom')" on:click="select_category('custom')">custom kinks</li>
            {#each categories as category}
                <li class:selected="is_selected(category.id)" on:click="select_category(category.id)">{category.name}</li>
            {/each}
            </ul>
            {:catch error}
            <p class="error">couldn't load??</p>
            {/await}
        </div>
        <div class="kink-menu">
            <h2>Kinks</h2>
            {#await selected_kinks}
            <p class="loading">loading...</p>
            {:then kinks}
            <div class="kinks menu-kinks" on:dragover|preventDefault="dragover(event, null)" on:drop|preventDefault="drop(event, null)">
                {#each kinks as kink}
                <div class="kink" class:selected="isKinkUsed(kink)" draggable={isKinkUnused(kink)} on:dragstart="dragstart(event, true)" data-id={kink.id}>
                    <p title={kink.description}>{kink.name}</p>
                    <p class="description">{kink.description}</p>
                    <div class="shortcuts">
                        <button class="shortcut" class:selected="isKinkInColumn(kink, 0)" data-target="0" on:click="toggleColumn(kink.id, 0)">
                            <svg class="icon heart"><use xlink:href="#heart"></use></svg>
                        </button>
                        <button class="shortcut" class:selected="isKinkInColumn(kink, 1)" data-target="1" on:click="toggleColumn(kink.id, 1)">
                            <svg class="icon check"><use xlink:href="#check"></use></svg>
                        </button>
                        <button class="shortcut" class:selected="isKinkInColumn(kink, 2)" data-target="2" on:click="toggleColumn(kink.id, 2)">
                            <svg class="icon tilde"><use xlink:href="#tilde"></use></svg>
                        </button>
                        <button class="shortcut" class:selected="isKinkInColumn(kink, 3)" data-target="3" on:click="toggleColumn(kink.id, 3)">
                            <svg class="icon no"><use xlink:href="#no"></use></svg>
                        </button>
                    </div>
                </div>
                {/each}
            </div>
            {:catch error}
            <p class="error">couldn't load??</p>
            {/await}
        </div>
    </aside>
    {#await full_columns}
    <p class="loading">loading...</p>
    {:then columns}
    {#each columns as column, i}
    <div class="column" on:dragover|preventDefault="dragover(event, i)" on:drop|preventDefault="drop(event, i)">
        <h2><svg class="icon {column.name}"><use xlink:href="#{column.name}"></use></svg></h2>
        <div class="kinks" data-kink-column={i}>
            {#each column.kinks as kink}
            <div class="kink" draggable="true" on:dragstart="dragstart(event, false)" on:dragend="dragend(event, i)" data-id={kink.id}>
                <p title={kink.description}>{kink.name}</p>
                <p class="description">{kink.description}</p>
            </div>
            {/each}
        </div>
    </div>
    {/each}
    {:catch error}
    <p class="error">couldn't load??</p>
    {/await}
</article>

<script>
    function decode_one(data) {
        let header = data.slice(0, 2);
        let column = header[0] >> 6;
        let type = header[0] >> 5 & 0b1;
        let intensity = header[0] >> 3 & 0b11;
        let rest = (header[0] & 0b111) << 8 | header[1];
        if (type === 0) {
            return [column, false, intensity, rest, data.slice(2)];
        } else {
            let text = data.slice(2, 2 + rest);
            const decoder = new TextDecoder('utf-8');
            text = decoder.decode(text);
            return [column, true, intensity, text, data.slice(2 + rest)];
        }
    }

    function encode_one([column, custom, intensity, value]) {
        let length = 2 + (custom ? value.length : 0);
        let result = new Uint8Array(length);
        if (custom) {
            const encoder = new TextEncoder('utf-8');
            let text = encoder.encode(value);
            result.set(text, 2);
            value = value.length;
        }
        let type = custom ? 1 : 0;
        result[0] = (column << 6 | type << 5 | intensity << 3 | ((value >> 8) & 0b111));
        result[1] = value & 0b11111111;
        return result;
    }

    function decode_all(data) {
        let result = [];
        while (data.length > 0) {
            let [column, custom, intensity, value, new_data] = decode_one(data);
            data = new_data;
            result.push([column, custom, intensity, value]);
        }
        return result;
    }

    function encode_all(kinks) {
        let pieces = kinks.map(encode_one);
        let total_length = pieces.map(x => x.length).reduce((a, b) => a + b, 0);
        let data = new Uint8Array(total_length);
        let position = 0;
        for (let piece of pieces) {
            data.set(piece, position);
            position += piece.length;
        }
        return data;
    }

    function hydrate(data) {
        let decoded = decode_all(data);
        let columns = [
            {name: "heart", kinks: []},
            {name: "check", kinks: []},
            {name: "tilde", kinks: []},
            {name: "no", kinks: []}
        ];
        for (let [column, custom, intensity, value] of decoded) {
            columns[column].kinks.push([custom, intensity, value]);
        }
        return columns;
    }

    function dehydrate(columns) {
        let data = [];
        for (let i = 0; i < columns.length; i++) {
            for (let [custom, intensity, value] of columns[i].kinks) {
                if (custom) {
                    // TODO figure out custom kinks
                }
                data.push([i, custom, intensity, value]);
            }
        }
        return encode_all(data);
    }

    function deserialize(hash) {
        hash = hash.replace(/!/g, '=');
        let string_data = atob(hash);
        let data = new Uint8Array(string_data.length);
        data.forEach((_, i) => data[i] = string_data.charCodeAt(i));
        return hydrate(data);
    }

    function serialize(columns) {
        let data = dehydrate(columns);
        let string_data = String.fromCharCode(...data);
        let b64 = btoa(string_data);
        return b64.replace(/=/g, '!');
    }

    function fetchKink(kink, db_data) {
        let [custom, intensity, value] = kink;
        if (custom) {
            let [name, description] = value.split('\n', 1);
            return {custom, intensity, name, description};
        } else {
            let {name, description} = db_data.kinks.find(k => k.id === value);
            return {custom, intensity, name, description, id: value};
        }
    }

    export default {
        data() {
            let columns = [
                {name: "heart", kinks: []},
                {name: "check", kinks: []},
                {name: "tilde", kinks: []},
                {name: "no", kinks: []}
            ];
            if (location.hash.startsWith('#')) {
                let hash = location.hash.substring(1);
                columns = deserialize(hash);
                console.log('Restoring', columns);
            }
            return {
                columns,
                db_promise: fetch('/kinks/', {
                    headers: {
                        'Accept': 'application/json',
                    }
                }).then(response => response.json()),
                selected_category: null,
            }
        },

        computed: {
            categories: ({ db_promise }) => db_promise.then(db_data => db_data.categories),
            selected_kinks: ({ db_promise, selected_category }) => db_promise.then(db_data => {
                if (selected_category === null) {
                    return db_data.kinks;
                } else if (selected_category === 'custom') {
                    // TODO what do
                    return [];
                } else {
                    return db_data.kinks.filter(k => k.category_id === selected_category);
                }
            }),
            is_selected: ({ selected_category }) => (c) => selected_category === c,
            isKinkUsed: ({ columns }) => (kink) => {
                return columns.some(({ kinks }) => kinks.some(k => k[2] === kink.id));
            },
            isKinkUnused: ({ columns }) => (kink) => {
                return columns.every(({ kinks }) => kinks.every(k => k[2] !== kink.id));
            },
            isKinkInColumn: ({ columns }) => (kink, column) => {
                let kinks = columns[column].kinks;
                return kinks.some(k => k[2] === kink.id);
            },
            full_columns: ({ columns, db_promise }) => db_promise.then(db_data => {
                return columns.map(column => ({
                    name: column.name,
                    kinks: column.kinks.map(x => fetchKink(x, db_data)),
                }))
            }),
            urlInfo: ({ columns }) => {
                return serialize(columns);
            },
            listUrl: ({ columns }) => {
                const urlInfo = serialize(columns);
                const url = new URL('/', location.href);
                url.search = urlInfo;
                url.hash = '';
                return url.href;
            },
        },

        methods: {
            select_category(category) {
                this.set({selected_category: category});
            },
            toggleColumn(id, column) {
                let { columns } = this.get();
                if (columns[column].kinks.some(k => k[2] === id)) {
                    columns[column].kinks = columns[column].kinks.filter(k => k[2] !== id);
                } else {
                    columns.forEach(c => {
                        c.kinks = c.kinks.filter(k => k[2] !== id)
                    });
                    columns[column].kinks.push([false, 0, id]);
                }
                this.set({ columns });
            },
            dragstart(event, fromMenu) {
                if (fromMenu) {
                    event.dataTransfer.effectAllowed = "copy";
                } else {
                    event.dataTransfer.effectAllowed = "move";
                }
                let id = event.target.dataset.id;
                event.dataTransfer.setData("text/plain", id);
            },
            dragover(event, column) {
                // can't reject illegitimate drags because we can't get the data out of the drag event 😔
                event.dataTransfer.dropEffect = event.dataTransfer.effectAllowed;
            },
            drop(event, column) {
                if (column !== null) {
                    const data = event.dataTransfer;
                    let id = parseInt(data.getData("text/plain"));
                    let columns = this.get().columns;
                    // must defer so that if we drag to ourself we add after we remove
                    // (there are almost certainly better ways to handle this)
                    setTimeout(() => {
                        columns[column].kinks = [...columns[column].kinks, [false, 0, id]];
                        this.set({ columns });
                    });
                }
            },
            dragend(event, column) {
                const data = event.dataTransfer;
                if (data.dropEffect === "move" && column !== null) {
                    let columns = this.get().columns;
                    let id = parseInt(event.target.dataset.id);
                    columns[column].kinks = columns[column].kinks.filter(k => k[2] !== id);
                    this.set({ columns });
                }
            },
        },

        onstate({ current }) {
            let url = current.urlInfo;
            history.replaceState(null, "", "#" + url);
        },
    };
</script>
